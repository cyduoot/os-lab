# 实验 0 扩充 1 - 链接器脚本

AIM 实验的核心部分是编写操作系统内核，这要求我们编写的程序能够直接在设备（无论物理
存在的还是虚拟的）上直接运行。C 库的后台是操作系统提供的系统调用接口，所以我们在没有
操作系统的时候就无法使用现有的 C 库。没有了 C 库，我们就必须显式告知链接器代码和数据
使用内存的方式，而完成这一任务的方法，就是编写链接器脚本。

## 实验目标

1. 初步理解 C 代码、汇编代码、机器指令与内存和符号进行交互的各种方式。
2. 理解链接器使用自身脚本控制产物（可执行文件、库或 libexec）内容使用内存的方式。
3. 对照简易手册，能够完成简单链接器脚本的编写和修改。
4. 熟悉对符号表和地址空间布局等问题进行调试的方法以及相关工具的使用。

## 实验步骤

我们准备了一个与内存交互比较复杂的程序，并给出编译使用的选项。请你编写适当的链接器
脚本，完成该程序的链接，使其能够完成设计要求。这些要求的具体作用，我们会在课堂上具体
进行讲解。

`labasm.S` 是一段 `x86_64` 平台的汇编语言程序，承担了 `crt0` 的一小部分任务。请确保：

1. `entry` 符号加载于 `0x400000` 地址，且符号解释为相等的值。
2. 任何其他 `.text` 节中的内容都加载于高于 `entry` 但小于 `0x500000` 的地址，其中
   符号均解释为与加载地址相等的值。
3. `entry` 符号作为最终可执行程序的入口。

`labmain.c` 是一段包含了 `x86_64` 平台内嵌汇编的 C 程序，其中定义了两个数组（`a` 和
`b`）并分别出现在 `.data` 和 `.data.hi` 节中。请确保：

1. 请确保链接时摆放 `.data`、`.bss` 和 `.rodata` 节，要求与 `.text` 相同。此程序当
   前并不会生成 `.bss` 或 `.rodata` 中的任何内容，请仍然摆放之，后续的实验我们会
   用到。
2. `.data.hi` 加载于不低于 `0x500000` 但不高于 `0x600000` 的地址段中合理的位置，
   但其中的符号解释为高于 `0x400000` 却低于 `0x500000` 的另外的合理值，这个值需要
   高于 `.rodata` 但低于 `.data`。
3. 导出符号 `data_hi_rombase`，解释为 `.data.hi` 的加载地址。
4. 导出符号 `data_hi_base`，解释为 `.data.hi` 的运行地址。
5. 导出符号 `data_hi_len`，解释为 `.data.hi` 实际占用的空间。这一符号在我们的程序中
   并未使用，在后续的实验中会用来完成一些比较棘手的工作。

对于整个程序，请确保：

1. 所有摆放了的节都有合理的对齐。
2. `.text`、`.rodata`、`.data`、`.bss` 这四个节按从低到高的顺序依次摆放。除了
   `.rodata` 和 `.data` 之间，其他的间隔中不允许拜访任何节。
3. 丢弃 `.eh_frame` 和 `.comment` 节。

由于使用了 `x86_64` 汇编语言，请使用 `x86_64` 平台上的原生工具链开展实验。我们建议
使用尽可能新版本的 `gcc` 和 `binutils`，因为开发实验时总是使用最新的工具，使用相似的
环境有助于少走弯路。

编译此程序所使用的 `gcc` 参数表示例如下：

`gcc -Wall -Wextra -Waddress -Wconversion -O2 -fno-builtin -mtune=native -nostdlib -Wl,--build-id=none labmain.c labasm.S -o labmain -T lab.lds`

在验收时，我们可能会对其中部分参数甚至程序本身进行一定程度的调整，考察链接器脚本在
各种不同条件下的表现。

## 实验提示

1. 对地址空间和符号进行静态检查的最佳工具是 `readelf`，其次是 `objdump`。
2. 由于 `linux` 的加载器不会考虑物理地址，所以用 `gdb` 来进行动态检查意义不大。
3. 由于我们还没有开始操作页表，`qemu` 提供的直接引导 `elf` 格式内核的功能现在还
   无法用于调试。

## 链接器脚本的简易手册

`ld` 的手册当前处于未被开发者维护的状态，有很多地方已经不再能描述 `ld` 本身的行为。
AIM 实验只使用链接器脚本的功能中的非常小的一个子集，在已测试的环境中，这些功能足够
完成实验（虽然可能无法产生最优方案）。我们允许但不建议使用其他功能，并且很可能无法
对这些额外的功能提供支持。

### ENTRY 语句

`ENTRY` 语句指定可执行文件的入口点。对于可执行的文件，这是必须的；对于库，是可选的。

任何连接器脚本都至多包含一处 `ENTRY` 语句，形式为 `ENTRY(值)`，其中可以是数值、
带后缀的数值（如 1M）、全局符号或者表达式。我们建议此处只使用单个符号。

### SECTIONS 语句块

`SECTIONS` 语句块总是必须的且只出现一次，描述输出文件的内存使用情况。形式为：

`SECTIONS { 若干输出节或赋值语句 }`

### 赋值语句

格式为 `. = 值;`，可以给全局符号赋值。显然每个符号只能有一个值，也就只应该赋值一次。
此处进行赋值的符号不应由任何代码定义过，但是可以被使用，在 C 中的使用与使用其他 `.o`
文件中定义的符号类似。应注意，C 语言永远将符号的解释值视为地址，请务必谨慎使用。

此语句还可以给游标变量 `.` 赋值。游标变量可以多次赋值但不允许减小。

赋值语句可以使用的值与 `ENTRY` 语句相同。

### 输出节

格式为 `输出节名称 : AT(加载地址) { 若干输入节或赋值语句 }`，其中 `AT(加载地址)`
是可选的，如果忽略，会默认为游标变量的当前值。有内容需要输出时，此语句创建一个输出
节，加载到加载地址，运行于游标变量的当前值（即按此地址计算其中符号的值，下同）。

在输出节中要给游标变量赋值的，我们只允许在游标变量上增加常数或使用 `ALIGN` 表达式。

在输出节中要给符号赋值的，我们只允许使用游标变量本身。

名称为 `/DISCARD/` 的输出节不会真的生成，其中摆放的任何内容都将在生成输出时丢弃。
丢弃某些节可能会导致 `gcc`（包含以 `CCLD` 为名调用的情况）给出警告或错误。

### 输入节

格式为 `*(输入节名称);`，描述所有输入文件中给定名称的节。所有涉及的内容将会合并，
但链接静态库会丢弃未使用的输入文件。`ld` 允许在此处进行较为复杂的匹配，但在
`linux` 内核等开源工程中很少使用，AIM 实验也无需使用。

